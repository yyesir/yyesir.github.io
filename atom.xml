<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随笔</title>
  
  
  <link href="https://yesir.github.io/atom.xml" rel="self"/>
  
  <link href="https://yesir.github.io/"/>
  <updated>2023-08-01T07:25:18.446Z</updated>
  <id>https://yesir.github.io/</id>
  
  <author>
    <name>yesir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++写日志到文件</title>
    <link href="https://yesir.github.io/2023/08/01/C-%E5%86%99%E6%97%A5%E5%BF%97%E5%88%B0%E6%96%87%E4%BB%B6/"/>
    <id>https://yesir.github.io/2023/08/01/C-%E5%86%99%E6%97%A5%E5%BF%97%E5%88%B0%E6%96%87%E4%BB%B6/</id>
    <published>2023-08-01T07:15:35.000Z</published>
    <updated>2023-08-01T07:25:18.446Z</updated>
    
    <content type="html"><![CDATA[<p>利用<code>fprintf</code>及可变参数来实现日志功能</p><span id="more"></span><blockquote><p>先封装一个<code>lock</code>类，用于同步写文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef __H_AEYE_LOCKER__</span></span><br><span class="line"><span class="comment">#define __H_AEYE_LOCKER__</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"></span><br><span class="line">class Locker</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    inline <span class="function"><span class="title">Locker</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    inline ~<span class="function"><span class="title">Locker</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void <span class="function"><span class="title">lock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    inline bool <span class="function"><span class="title">tryLock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (pthread_mutex_trylock(&amp;mutex) == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void <span class="function"><span class="title">unlock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    pthread_mutex_t mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RwLocker</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    inline <span class="function"><span class="title">RwLocker</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_init(&amp;rwLocker, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    inline ~<span class="function"><span class="title">RwLocker</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_destroy(&amp;rwLocker);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void <span class="function"><span class="title">rLock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwLocker);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void <span class="function"><span class="title">wLock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwLocker);</span><br><span class="line">    &#125;</span><br><span class="line">    inline bool <span class="function"><span class="title">tryRLock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (pthread_rwlock_tryrdlock(&amp;rwLocker) == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    inline bool <span class="function"><span class="title">tryWLock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (pthread_rwlock_trywrlock(&amp;rwLocker) == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    inline void <span class="function"><span class="title">unlock</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwLocker);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    pthread_rwlock_t rwLocker;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><blockquote><p>对外接口，日志类头文件,这里使用了单实例类</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef __H_AEYE_LOG__</span></span><br><span class="line"><span class="comment">#define __H_AEYE_LOG__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;locker.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LEVEL_NONE  0</span></span><br><span class="line"><span class="comment">#define LEVEL_ERROR 1</span></span><br><span class="line"><span class="comment">#define LEVEL_ALARM 2</span></span><br><span class="line"><span class="comment">#define LEVEL_PROMT 3</span></span><br><span class="line"><span class="comment">#define LEVEL_TRACE 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOG(LEVEL, FMT, ...) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; \</span><br><span class="line">        <span class="keyword">if</span> (NULL != FMT) &#123; \</span><br><span class="line">            Logger::Log::getInstance().writeLine(LEVEL, __func__, __LINE__, FMT, <span class="comment">## __VA_ARGS__); \</span></span><br><span class="line">        &#125; \</span><br><span class="line">    &#125; <span class="keyword">while</span>(0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGN(FMT, ...) LOG(LEVEL_NONE, FMT, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGE(FMT, ...) LOG(LEVEL_ERROR, FMT, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGA(FMT, ...) LOG(LEVEL_ALARM, FMT, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGP(FMT, ...) LOG(LEVEL_PROMT, FMT, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGT(FMT, ...) LOG(LEVEL_TRACE, FMT, ## __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define NO_CONSTRUCT_FUN_MACRO(C) \</span></span><br><span class="line">public: \</span><br><span class="line">    C(const C&amp;) = delete; \</span><br><span class="line">    C&amp; operator=(const C&amp;) = delete;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define INHERIT_SINGLETON_MACRO(C) \</span></span><br><span class="line">    friend class Singleton&lt;C&gt;; \</span><br><span class="line">    NO_CONSTRUCT_FUN_MACRO(C)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static T&amp; <span class="function"><span class="title">getInstance</span></span>()</span><br><span class="line">    &#123;</span><br><span class="line">        static T instance;</span><br><span class="line">        <span class="built_in">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    NO_CONSTRUCT_FUN_MACRO(Singleton);</span><br><span class="line">protected:</span><br><span class="line">    <span class="function"><span class="title">Singleton</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">namespace Logger</span><br><span class="line">&#123;</span><br><span class="line">class Log : public Singleton&lt;Log&gt;</span><br><span class="line">&#123;</span><br><span class="line">    INHERIT_SINGLETON_MACRO(Log);</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    void setLevel(int level);</span><br><span class="line"></span><br><span class="line">    void writeLine(int level, const char *func_name, unsigned int line, const char *<span class="built_in">fmt</span>, ...);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    FILE *m_pLogFile;</span><br><span class="line">    int m_level;</span><br><span class="line">    Locker m_LogLocker;</span><br><span class="line">    Locker m_TimeLogLocker;</span><br><span class="line"></span><br><span class="line">    Log(const char* logName = <span class="string">&quot;./log.log&quot;</span>);</span><br><span class="line">    ~Log();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><blockquote><p>具体的实现，将内容输出到文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;log.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdarg.h&gt;</span></span><br><span class="line"></span><br><span class="line">namespace Logger</span><br><span class="line">&#123;</span><br><span class="line">Log::Log(const char* logName)</span><br><span class="line">&#123;</span><br><span class="line">    m_pLogFile = NULL;</span><br><span class="line">    m_level = LEVEL_PROMT;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef LOG_FILE</span></span><br><span class="line">    m_pLogFile = fopen(logName, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="function"><span class="title">Log</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (NULL != m_pLogFile)</span><br><span class="line">    &#123;</span><br><span class="line">        fclose(m_pLogFile);</span><br><span class="line">        m_pLogFile = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Log::writeLine(int level, const char *func_name, unsigned int line, const char *<span class="built_in">fmt</span>, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &gt; m_level)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, <span class="built_in">fmt</span>);</span><br><span class="line">    struct timespec current_time;</span><br><span class="line">struct tm format_time;</span><br><span class="line">memset(&amp;current_time, 0, sizeof(current_time));</span><br><span class="line">clock_gettime(CLOCK_REALTIME, &amp;current_time);</span><br><span class="line">localtime_r(&amp;current_time.tv_sec, &amp;format_time);</span><br><span class="line">    <span class="keyword">if</span> (NULL != m_pLogFile)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LogLocker.lock();</span><br><span class="line">        fprintf(m_pLogFile, <span class="string">&quot;[%02d-%02d-%02d %02d:%02d:%02d.%ld] [%s] [%d] &quot;</span>, format_time.tm_year+1900,</span><br><span class="line">            format_time.tm_mon+1,</span><br><span class="line">            format_time.tm_mday,</span><br><span class="line">            format_time.tm_hour,</span><br><span class="line">            format_time.tm_min,</span><br><span class="line">            format_time.tm_sec,</span><br><span class="line">            current_time.tv_nsec,</span><br><span class="line">            func_name,</span><br><span class="line">            line);</span><br><span class="line">        vfprintf(m_pLogFile, <span class="built_in">fmt</span>, ap);</span><br><span class="line">        fprintf(m_pLogFile, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        fflush(m_pLogFile);</span><br><span class="line">        m_LogLocker.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        vprintf(<span class="built_in">fmt</span>, ap);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Log::setLevel(int level)</span><br><span class="line">&#123;</span><br><span class="line">    m_level = level;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上就是简单的日志类，当然还可以进一步实现根据日期每天创建单独的日志文件，也可以根据文件大小，写多个日志文件</p></blockquote><ul><li>使用方法如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;log.h&quot;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    LOG(LEVEL_ERROR, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;init begin.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用&lt;code&gt;fprintf&lt;/code&gt;及可变参数来实现日志功能&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>添加win右键菜单打开CMD</title>
    <link href="https://yesir.github.io/2023/07/21/%E6%B7%BB%E5%8A%A0win%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%89%93%E5%BC%80CMD/"/>
    <id>https://yesir.github.io/2023/07/21/%E6%B7%BB%E5%8A%A0win%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E6%89%93%E5%BC%80CMD/</id>
    <published>2023-07-21T07:36:52.000Z</published>
    <updated>2023-07-21T07:43:09.243Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实现在<code>windows</code>系统，打开目录点右键打开<code>CMD</code>命令窗口</p></blockquote><span id="more"></span><blockquote><p>新建文本文件,写入以下内容，另存为<code>.reg</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\OpenCmdHere]</span><br><span class="line">@=&quot;在终端中打开&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\OpenCmdHere\command]</span><br><span class="line">@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot; \&quot;--cd=%v.\&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\LibraryFolder\background\shell\OpenCmdHere]</span><br><span class="line">@=&quot;CmdHere&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\LibraryFolder\background\shell\OpenCmdHere\command]</span><br><span class="line">@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot; \&quot;--cd=%v.\&quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>双击运行添加到注册表,操作完成后在任意一目录点右键选择<code>在终端中打开</code>即打开了<code>CMD</code>窗口</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;实现在&lt;code&gt;windows&lt;/code&gt;系统，打开目录点右键打开&lt;code&gt;CMD&lt;/code&gt;命令窗口&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://yesir.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>通过fcitx-dbus接口将文字写到输入框</title>
    <link href="https://yesir.github.io/2023/07/20/%E9%80%9A%E8%BF%87fcitx-dbus%E6%8E%A5%E5%8F%A3%E5%B0%86%E6%96%87%E5%AD%97%E5%86%99%E5%88%B0%E8%BE%93%E5%85%A5%E6%A1%86/"/>
    <id>https://yesir.github.io/2023/07/20/%E9%80%9A%E8%BF%87fcitx-dbus%E6%8E%A5%E5%8F%A3%E5%B0%86%E6%96%87%E5%AD%97%E5%86%99%E5%88%B0%E8%BE%93%E5%85%A5%E6%A1%86/</id>
    <published>2023-07-20T06:19:04.000Z</published>
    <updated>2023-07-20T06:25:10.449Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>DBus</code>库与<code>DBus</code>系统通信，并使用<code>fcitx</code>的<code>DBus接口</code>发送相应的消息,从而实现将文字写到输入框</p><span id="more"></span><blockquote><p>以下是简单的代码示例:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;dbus/dbus.h&gt;</span></span><br><span class="line"></span><br><span class="line">void send_chinese_input(const char* input_text) &#123;</span><br><span class="line">    DBusConnection* connection;</span><br><span class="line">    DBusError error;</span><br><span class="line">    dbus_error_init(&amp;error);</span><br><span class="line"></span><br><span class="line">    // 建立与DBus系统的连接</span><br><span class="line">    connection = dbus_bus_get(DBUS_BUS_SESSION, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (dbus_error_is_set(&amp;error)) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">&quot;Unable to connect to the D-Bus session bus: %s\n&quot;</span>, error.message);</span><br><span class="line">        dbus_error_free(&amp;error);</span><br><span class="line">        <span class="built_in">exit</span>(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个DBus消息</span><br><span class="line">    DBusMessage* message;</span><br><span class="line">    message = dbus_message_new_method_call(</span><br><span class="line">        <span class="string">&quot;org.fcitx.Fcitx&quot;</span>,                           // 接口所在的DBus名称</span><br><span class="line">        <span class="string">&quot;/inputmethod&quot;</span>,                              // 接口对象的路径</span><br><span class="line">        <span class="string">&quot;org.fcitx.Fcitx.InputMethod1&quot;</span>,               // 接口名称</span><br><span class="line">        <span class="string">&quot;ProcessKeyEvent&quot;</span>                            // 方法名称</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">// 如果只发送按键，添加方法参数（按键值和状态）</span><br><span class="line">    //dbus_uint32_t keyval = 65;  // 示例按键值为<span class="string">&#x27;A&#x27;</span></span><br><span class="line">    //dbus_uint32_t keycode = 38; // 示例按键码为<span class="string">&#x27;KEY_A&#x27;</span>（可以根据需要更改）</span><br><span class="line">    //dbus_uint32_t state = 0;    // 示例状态为0（可以根据需要更改）</span><br><span class="line"></span><br><span class="line">    // 添加方法参数（中文输入文本）</span><br><span class="line">    dbus_uint32_t keyval = 0;  </span><br><span class="line">    dbus_uint32_t keycode = 0;</span><br><span class="line">    dbus_uint32_t state = 0;</span><br><span class="line">    const char* utf8_text = input_text;</span><br><span class="line"></span><br><span class="line">    dbus_message_append_args(</span><br><span class="line">        message,</span><br><span class="line">        DBUS_TYPE_UINT32, &amp;keyval,</span><br><span class="line">        DBUS_TYPE_UINT32, &amp;keycode,</span><br><span class="line">        DBUS_TYPE_UINT32, &amp;state,</span><br><span class="line">        DBUS_TYPE_STRING, &amp;utf8_text,</span><br><span class="line">        DBUS_TYPE_INVALID</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 发送DBus消息，并等待响应</span><br><span class="line">    DBusPendingCall* pending;</span><br><span class="line">    dbus_connection_send_with_reply(connection, message, &amp;pending, -1);</span><br><span class="line">    dbus_connection_flush(connection);</span><br><span class="line"></span><br><span class="line">    // 等待DBus响应</span><br><span class="line">    dbus_pending_call_block(pending);</span><br><span class="line"></span><br><span class="line">    // 获取DBus响应</span><br><span class="line">    DBusMessage* reply = dbus_pending_call_steal_reply(pending);</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        dbus_message_unref(reply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 释放资源</span><br><span class="line">    dbus_message_unref(message);</span><br><span class="line">    dbus_pending_call_unref(pending);</span><br><span class="line">    dbus_connection_unref(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    // 要输入的中文文本</span><br><span class="line">    const char* chinese_text = <span class="string">&quot;你好，世界！&quot;</span>;</span><br><span class="line"></span><br><span class="line">    // 发送中文输入</span><br><span class="line">    send_chinese_input(chinese_text);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译方法:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o fcitx_test fcitx_test.c `pkg-config --libs --cflags dbus-1`</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用&lt;code&gt;DBus&lt;/code&gt;库与&lt;code&gt;DBus&lt;/code&gt;系统通信，并使用&lt;code&gt;fcitx&lt;/code&gt;的&lt;code&gt;DBus接口&lt;/code&gt;发送相应的消息,从而实现将文字写到输入框&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Win32利用计划任务开机启动UI程序</title>
    <link href="https://yesir.github.io/2023/07/06/Win32%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8UI%E7%A8%8B%E5%BA%8F/"/>
    <id>https://yesir.github.io/2023/07/06/Win32%E5%88%A9%E7%94%A8%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8UI%E7%A8%8B%E5%BA%8F/</id>
    <published>2023-07-06T02:21:45.000Z</published>
    <updated>2023-07-06T02:28:19.782Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下，都是利用win服务创建开机启动程序，但是如果启动的是UI程序，此时用服务程序创建容易出现进程启动了，但是UI显示不了的问题<br>因此，下面使用一种利用计划的方式来实现开机启动</p><span id="more"></span><blockquote><p><code>MyTaskSchedule.h</code></p></blockquote><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef MYTASKSCHEDULE_H_</span></span><br><span class="line"><span class="comment">#define MYTASKSCHEDULE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;Windows.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;taskschd.h&gt;</span></span><br><span class="line"></span><br><span class="line">class CMyTaskSchedule</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CMyTaskSchedule(void);</span><br><span class="line">virtual ~CMyTaskSchedule(void);</span><br><span class="line">BOOL Delete(char *lpszTaskName);</span><br><span class="line">BOOL DeleteFolder(char *lpszFolderName);</span><br><span class="line">BOOL NewTask(char *lpszTaskName, char *lpszProgramPath, char *lpszParameters, char *lpszAuthor);</span><br><span class="line">BOOL IsExist(char *lpszTaskName);</span><br><span class="line">BOOL IsTaskValid(char *lpszTaskName);</span><br><span class="line">BOOL Run(char *lpszTaskName, char *lpszParam);</span><br><span class="line">BOOL IsEnable(char *lpszTaskName);</span><br><span class="line">BOOL SetEnable(char *lpszTaskName, BOOL bEnable);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">ITaskService* m_lpITS;</span><br><span class="line">ITaskFolder* m_lpRootFolder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><blockquote><p><code>MyTaskSchedule.cpp</code></p></blockquote><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;MyTaskSchedule.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;atlbase.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;comdef.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;comutil.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;OAIDL.H&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pragma comment(lib, &quot;taskschd.lib&quot;)  </span></span><br><span class="line"><span class="comment"># pragma comment(lib, &quot;comsupp.lib&quot;) </span></span><br><span class="line"></span><br><span class="line">void ShowError(char *lpszText, DWORD dwErrCode)</span><br><span class="line">&#123;</span><br><span class="line">char szErr[MAX_PATH] = &#123;0&#125;;</span><br><span class="line">::wsprintf(szErr, <span class="string">&quot;%s Error!\nError Code Is:0x%08x\n&quot;</span>, lpszText, dwErrCode);</span><br><span class="line">::MessageBox(NULL, szErr, <span class="string">&quot;ERROR&quot;</span>, MB_OK | MB_ICONERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMyTaskSchedule::CMyTaskSchedule(void)</span><br><span class="line">&#123;</span><br><span class="line">m_lpITS = NULL;</span><br><span class="line">m_lpRootFolder = NULL;</span><br><span class="line">// 初始化COM</span><br><span class="line">HRESULT hr = ::CoInitialize(NULL);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;CoInitialize&quot;</span>, hr);</span><br><span class="line">&#125;</span><br><span class="line">// 创建一个任务服务（Task Service）实例</span><br><span class="line">hr = ::CoCreateInstance(CLSID_TaskScheduler,</span><br><span class="line">NULL,</span><br><span class="line">CLSCTX_INPROC_SERVER,</span><br><span class="line">IID_ITaskService,</span><br><span class="line">(LPVOID *)(&amp;m_lpITS));</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;CoCreateInstance&quot;</span>, hr);</span><br><span class="line">&#125;</span><br><span class="line">// 连接到任务服务（Task Service）</span><br><span class="line">hr = m_lpITS-&gt;Connect(_variant_t(), _variant_t(), _variant_t(), _variant_t());</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;ITaskService::Connect&quot;</span>, hr);</span><br><span class="line">&#125;</span><br><span class="line">// 获取Root Task Folder的指针，这个指针指向的是新注册的任务</span><br><span class="line">hr = m_lpITS-&gt;GetFolder(_bstr_t(<span class="string">&quot;\\&quot;</span>), &amp;m_lpRootFolder);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;ITaskService::GetFolder&quot;</span>, hr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMyTaskSchedule::~CMyTaskSchedule(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m_lpITS)</span><br><span class="line">&#123;</span><br><span class="line">m_lpITS-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line">m_lpRootFolder-&gt;Release();</span><br><span class="line">&#125;</span><br><span class="line">// 卸载COM</span><br><span class="line">::CoUninitialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::Delete(char *lpszTaskName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">CComVariant variantTaskName(NULL);</span><br><span class="line">variantTaskName = lpszTaskName;</span><br><span class="line">HRESULT hr = m_lpRootFolder-&gt;DeleteTask(variantTaskName.bstrVal, 0);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::DeleteFolder(char *lpszFolderName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">CComVariant variantFolderName(NULL);</span><br><span class="line">variantFolderName = lpszFolderName;</span><br><span class="line">HRESULT hr = m_lpRootFolder-&gt;DeleteFolder(variantFolderName.bstrVal, 0);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::NewTask(char *lpszTaskName, char *lpszProgramPath, char *lpszParameters, char *lpszAuthor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 如果存在相同的计划任务，则删除</span><br><span class="line">Delete(lpszTaskName);</span><br><span class="line">// 创建任务定义对象来创建任务</span><br><span class="line">ITaskDefinition *pTaskDefinition = NULL;</span><br><span class="line">HRESULT hr = m_lpITS-&gt;NewTask(0, &amp;pTaskDefinition);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;ITaskService::NewTask&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 设置注册信息 */</span><br><span class="line">IRegistrationInfo *pRegInfo = NULL;</span><br><span class="line">CComVariant variantAuthor(NULL);</span><br><span class="line">variantAuthor = lpszAuthor;</span><br><span class="line">hr = pTaskDefinition-&gt;get_RegistrationInfo(&amp;pRegInfo);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;pTaskDefinition::get_RegistrationInfo&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 设置作者信息</span><br><span class="line">hr = pRegInfo-&gt;put_Author(variantAuthor.bstrVal);</span><br><span class="line">pRegInfo-&gt;Release();</span><br><span class="line"></span><br><span class="line">/* 设置登录类型和运行权限 */</span><br><span class="line">IPrincipal *pPrincipal = NULL;</span><br><span class="line">hr = pTaskDefinition-&gt;get_Principal(&amp;pPrincipal);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;pTaskDefinition::get_Principal&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 设置登录类型</span><br><span class="line">hr = pPrincipal-&gt;put_LogonType(TASK_LOGON_INTERACTIVE_TOKEN);</span><br><span class="line">// 设置运行权限</span><br><span class="line">// 最高权限</span><br><span class="line">hr = pPrincipal-&gt;put_RunLevel(TASK_RUNLEVEL_HIGHEST);  </span><br><span class="line">pPrincipal-&gt;Release();</span><br><span class="line"></span><br><span class="line">/* 设置其他信息 */</span><br><span class="line">ITaskSettings *pSettting = NULL;</span><br><span class="line">hr = pTaskDefinition-&gt;get_Settings(&amp;pSettting);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;pTaskDefinition::get_Settings&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 设置其他信息</span><br><span class="line">hr = pSettting-&gt;put_StopIfGoingOnBatteries(VARIANT_FALSE);</span><br><span class="line">hr = pSettting-&gt;put_DisallowStartIfOnBatteries(VARIANT_FALSE);</span><br><span class="line">hr = pSettting-&gt;put_AllowDemandStart(VARIANT_TRUE);</span><br><span class="line">hr = pSettting-&gt;put_StartWhenAvailable(VARIANT_FALSE);</span><br><span class="line">hr = pSettting-&gt;put_MultipleInstances(TASK_INSTANCES_PARALLEL);</span><br><span class="line">pSettting-&gt;Release();</span><br><span class="line"></span><br><span class="line">/* 创建执行动作 */</span><br><span class="line">IActionCollection *pActionCollect = NULL;</span><br><span class="line">hr = pTaskDefinition-&gt;get_Actions(&amp;pActionCollect);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;pTaskDefinition::get_Actions&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">IAction *pAction = NULL;</span><br><span class="line">// 创建执行操作</span><br><span class="line">hr = pActionCollect-&gt;Create(TASK_ACTION_EXEC, &amp;pAction);</span><br><span class="line">pActionCollect-&gt;Release();</span><br><span class="line"></span><br><span class="line">/* 设置执行程序路径和参数 */</span><br><span class="line">CComVariant variantProgramPath(NULL);</span><br><span class="line">CComVariant variantParameters(NULL);</span><br><span class="line">IExecAction *pExecAction = NULL;</span><br><span class="line">hr = pAction-&gt;QueryInterface(IID_IExecAction, (PVOID *)(&amp;pExecAction));</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">pAction-&gt;Release();</span><br><span class="line">ShowError(<span class="string">&quot;IAction::QueryInterface&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">pAction-&gt;Release();</span><br><span class="line">// 设置程序路径和参数</span><br><span class="line">variantProgramPath = lpszProgramPath;</span><br><span class="line">variantParameters = lpszParameters;</span><br><span class="line">pExecAction-&gt;put_Path(variantProgramPath.bstrVal);</span><br><span class="line">pExecAction-&gt;put_Arguments(variantParameters.bstrVal);</span><br><span class="line">pExecAction-&gt;Release();</span><br><span class="line"></span><br><span class="line">/* 创建触发器，实现用户登陆自启动 */</span><br><span class="line">ITriggerCollection *pTriggers = NULL;</span><br><span class="line">hr = pTaskDefinition-&gt;get_Triggers(&amp;pTriggers);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;pTaskDefinition::get_Triggers&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 创建触发器</span><br><span class="line">ITrigger *pTrigger = NULL;</span><br><span class="line">hr = pTriggers-&gt;Create(TASK_TRIGGER_LOGON, &amp;pTrigger);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">ShowError(<span class="string">&quot;ITriggerCollection::Create&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 注册任务计划  */</span><br><span class="line">IRegisteredTask *pRegisteredTask = NULL;</span><br><span class="line">CComVariant variantTaskName(NULL);</span><br><span class="line">variantTaskName = lpszTaskName;</span><br><span class="line">hr = m_lpRootFolder-&gt;RegisterTaskDefinition(variantTaskName.bstrVal,</span><br><span class="line">pTaskDefinition,</span><br><span class="line">TASK_CREATE_OR_UPDATE,</span><br><span class="line">_variant_t(),</span><br><span class="line">_variant_t(),</span><br><span class="line">TASK_LOGON_INTERACTIVE_TOKEN,</span><br><span class="line">_variant_t(<span class="string">&quot;&quot;</span>),</span><br><span class="line">&amp;pRegisteredTask);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">pTaskDefinition-&gt;Release();</span><br><span class="line">ShowError(<span class="string">&quot;ITaskFolder::RegisterTaskDefinition&quot;</span>, hr);</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">pTaskDefinition-&gt;Release();</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::IsExist(char *lpszTaskName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line">CComVariant variantTaskName(NULL);</span><br><span class="line">CComVariant variantEnable(NULL);</span><br><span class="line">variantTaskName = lpszTaskName;                     // 任务计划名称</span><br><span class="line">IRegisteredTask *pRegisteredTask = NULL;</span><br><span class="line">// 获取任务计划</span><br><span class="line">hr = m_lpRootFolder-&gt;GetTask(variantTaskName.bstrVal, &amp;pRegisteredTask);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr) || (NULL == pRegisteredTask))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::IsTaskValid(char *lpszTaskName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line">CComVariant variantTaskName(NULL);</span><br><span class="line">CComVariant variantEnable(NULL);</span><br><span class="line">variantTaskName = lpszTaskName;                     // 任务计划名称</span><br><span class="line">IRegisteredTask *pRegisteredTask = NULL;</span><br><span class="line">// 获取任务计划</span><br><span class="line">hr = m_lpRootFolder-&gt;GetTask(variantTaskName.bstrVal, &amp;pRegisteredTask);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr) || (NULL == pRegisteredTask))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 获取任务状态</span><br><span class="line">TASK_STATE taskState;</span><br><span class="line">hr = pRegisteredTask-&gt;get_State(&amp;taskState);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line">// 无效</span><br><span class="line"><span class="keyword">if</span>(TASK_STATE_DISABLED == taskState)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::Run(char *lpszTaskName, char *lpszParam)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line">CComVariant variantTaskName(NULL);</span><br><span class="line">CComVariant variantParameters(NULL);</span><br><span class="line">variantTaskName = lpszTaskName;</span><br><span class="line">variantParameters = lpszParam;</span><br><span class="line"></span><br><span class="line">// 获取任务计划</span><br><span class="line">IRegisteredTask *pRegisteredTask = NULL;</span><br><span class="line">hr = m_lpRootFolder-&gt;GetTask(variantTaskName.bstrVal, &amp;pRegisteredTask);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr) || (NULL == pRegisteredTask))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 运行</span><br><span class="line">hr = pRegisteredTask-&gt;Run(variantParameters, NULL);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr))</span><br><span class="line">&#123;</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::IsEnable(char *lpszTaskName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line">CComVariant variantTaskName(NULL);</span><br><span class="line">CComVariant variantEnable(NULL);</span><br><span class="line">variantTaskName = lpszTaskName;                     // 任务计划名称</span><br><span class="line">IRegisteredTask *pRegisteredTask = NULL;</span><br><span class="line">// 获取任务计划</span><br><span class="line">hr = m_lpRootFolder-&gt;GetTask(variantTaskName.bstrVal, &amp;pRegisteredTask);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr) || (NULL == pRegisteredTask))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 获取是否已经启动</span><br><span class="line">pRegisteredTask-&gt;get_Enabled(&amp;variantEnable.boolVal);</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line"><span class="keyword">if</span>(ATL_VARIANT_FALSE == variantEnable.boolVal)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL CMyTaskSchedule::SetEnable(char *lpszTaskName, BOOL bEnable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(NULL == m_lpRootFolder)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line">CComVariant variantTaskName(NULL);</span><br><span class="line">CComVariant variantEnable(NULL);</span><br><span class="line">variantTaskName = lpszTaskName;                     // 任务计划名称</span><br><span class="line">variantEnable = bEnable;                            // 是否启动</span><br><span class="line">IRegisteredTask *pRegisteredTask = NULL;</span><br><span class="line">// 获取任务计划</span><br><span class="line">hr = m_lpRootFolder-&gt;GetTask(variantTaskName.bstrVal, &amp;pRegisteredTask);</span><br><span class="line"><span class="keyword">if</span>(FAILED(hr) || (NULL == pRegisteredTask))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">// 设置是否启动</span><br><span class="line">pRegisteredTask-&gt;put_Enabled(variantEnable.boolVal);</span><br><span class="line">pRegisteredTask-&gt;Release();</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;MyTaskSchedule.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">CMyTaskSchedule task;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line">// 创建 任务计划</span><br><span class="line">bRet = task.NewTask(<span class="string">&quot;程序名&quot;</span>, <span class="string">&quot;程序路径&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create Task Schedule Error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 暂停</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create Task Schedule OK!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 卸载 任务计划</span><br><span class="line">bRet = task.Delete(<span class="string">&quot;程序名&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Delete Task Schedule Error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Delete Task Schedule OK!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常情况下，都是利用win服务创建开机启动程序，但是如果启动的是UI程序，此时用服务程序创建容易出现进程启动了，但是UI显示不了的问题&lt;br&gt;因此，下面使用一种利用计划的方式来实现开机启动&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>利用crontab开机执行脚本</title>
    <link href="https://yesir.github.io/2023/07/03/%E5%88%A9%E7%94%A8crontab%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    <id>https://yesir.github.io/2023/07/03/%E5%88%A9%E7%94%A8crontab%E5%BC%80%E6%9C%BA%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC/</id>
    <published>2023-07-03T09:30:42.000Z</published>
    <updated>2023-07-04T07:57:44.954Z</updated>
    
    <content type="html"><![CDATA[<p>解决在定制的<code>aarch64 uos</code>系统中，开机启动手写输入法时添加到<code>/etc/xdg/autostart</code>或<code>/home/user/.config/autostart</code>目录都启动不了的问题</p><span id="more"></span><p><code>crontab</code>定时任务分为脚本任务和系统自带命令<br>如果有这样一个脚本任务，仅仅需要开机后运行一次，那么，<code>crontab</code>结合<code>@reboot</code>是一个不错的选择。<br>如果是系统自带命令任务，<code>@reboot</code>不一定会执行，由于系统开机初始化，很有可能系统自带命令运行环境并不满足，但<code>crontab</code>已经开始执行<code>@reboot</code>，从而造成命令运行失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment">#进入编辑，输入如下行</span></span><br><span class="line">@reboot /home/test.sh <span class="comment">#开机马上启动这个脚本，如果脚本中有依赖系统中其他服务，会发生因为其他服务启动不完全，而导致自己脚本失败的情况</span></span><br><span class="line">@reboot <span class="built_in">sleep</span> 60; /home/test.sh <span class="comment">#最好加上休眠一会，等待其他服务启动完全了，再启动自己的脚本</span></span><br><span class="line">@reboot (<span class="built_in">sleep</span> 60; sh /home/test.sh) <span class="comment">#设置脚本在启动后的60s启动、/home\test.sh 就是脚本的存放地址</span></span><br></pre></td></tr></table></figure><blockquote><p><code>shell</code>命令添加<code>crontab</code>任务</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">利用crontab -l 加 crontab file 两个命令实现自动添加</span><br><span class="line"></span><br><span class="line">crontab -l &gt; conf &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;* * * * * hostname &gt;&gt; /tmp/tmp.txt&quot;</span> &gt;&gt; conf &amp;&amp; crontab conf &amp;&amp; <span class="built_in">rm</span> -f conf</span><br><span class="line">由于crontab file会覆盖原有定时任务，所以使用 crontab -l 先导出原有任务到临时文件 “conf” 再追加新定时任务</span><br><span class="line"></span><br><span class="line">优点：不限用户，任何有crontab权限的用户都能执行</span><br><span class="line"></span><br><span class="line">缺点：稍微复杂</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;解决在定制的&lt;code&gt;aarch64 uos&lt;/code&gt;系统中，开机启动手写输入法时添加到&lt;code&gt;/etc/xdg/autostart&lt;/code&gt;或&lt;code&gt;/home/user/.config/autostart&lt;/code&gt;目录都启动不了的问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://yesir.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python强制结束线程</title>
    <link href="https://yesir.github.io/2023/06/27/Python%E5%BC%BA%E5%88%B6%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B/"/>
    <id>https://yesir.github.io/2023/06/27/Python%E5%BC%BA%E5%88%B6%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B/</id>
    <published>2023-06-27T02:23:46.000Z</published>
    <updated>2023-06-27T02:30:53.906Z</updated>
    
    <content type="html"><![CDATA[<p>利用<code>ctypes</code>强行杀掉线程</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">import inspect</span><br><span class="line">import ctypes</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def _async_raise(tid, exctype):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;raises the exception, performs cleanup if needed&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    tid = ctypes.c_long(tid)</span><br><span class="line">    <span class="keyword">if</span> not inspect.isclass(exctype):</span><br><span class="line">        exctype = <span class="built_in">type</span>(exctype)</span><br><span class="line">    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))</span><br><span class="line">    <span class="keyword">if</span> res == 0:</span><br><span class="line">        raise ValueError(<span class="string">&quot;invalid thread id&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> res != 1:</span><br><span class="line">        <span class="comment"># &quot;&quot;&quot;if it returns a number greater than one, you&#x27;re in trouble,</span></span><br><span class="line">        <span class="comment"># and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;</span></span><br><span class="line">        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)</span><br><span class="line">        raise SystemError(<span class="string">&quot;PyThreadState_SetAsyncExc failed&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def stop_thread(thread):</span><br><span class="line">    _async_raise(thread.ident, SystemExit)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def thread_run(data):</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t = threading.Thread(target=thread_run,args=(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">    t.start()</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    stop_thread(t)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;stoped&quot;</span>)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    t1 = threading.Thread(target=thread_run,args=(<span class="string">&quot;2&quot;</span>))</span><br><span class="line">    t1.start()</span><br><span class="line">    time.sleep(0.001)</span><br><span class="line">    stop_thread(t1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;stoped&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用&lt;code&gt;ctypes&lt;/code&gt;强行杀掉线程&lt;/p&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://yesir.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Win32 Dll中加载图片资源</title>
    <link href="https://yesir.github.io/2023/05/31/Win32-Dll%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/"/>
    <id>https://yesir.github.io/2023/05/31/Win32-Dll%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90/</id>
    <published>2023-05-31T08:07:20.000Z</published>
    <updated>2023-05-31T08:38:18.020Z</updated>
    
    <content type="html"><![CDATA[<p>项目上有需求，要求在提供给第三方的SDK中，将bmp图像一起打包到dll文件中</p><span id="more"></span><blockquote><p>首先按照普通工程的方式，将bmp以资源的方式加载到项目中</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*@brief将资源中的图片转换成byte</span></span><br><span class="line"><span class="comment">*@param:</span></span><br><span class="line"><span class="comment">*参数说明如下表</span></span><br><span class="line"><span class="comment">*name|type|param direction|description of param</span></span><br><span class="line"><span class="comment">*----------------|---------------|-----------------------|------------------------</span></span><br><span class="line"><span class="comment">*bmpId    |int |[in]|加载到项目中的bmp资源ID</span></span><br><span class="line"><span class="comment">*dwSize    |int&amp;|[out]|返回bmp图像数据大小</span></span><br><span class="line"><span class="comment">*@return</span></span><br><span class="line"><span class="comment">*返回bmp图片数据,不包含bmp头信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title">ConvertBmpToByteArray</span><span class="params">(<span class="type">int</span> bmpId, <span class="type">int</span>&amp; dwSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE hInstance = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;Test.DLL&quot;</span>); <span class="comment">// 获取当前模块句柄,假设dll导出文件名为Test.dll</span></span><br><span class="line"><span class="comment">//如果在GetModuleHandle传的是NULL，在第三方调用时会查找不到资源</span></span><br><span class="line"><span class="keyword">if</span> (hInstance == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s GetModuleHandle GetLastError: %d\n&quot;</span>, __FUNCTION__, n);</span><br><span class="line">&#125;</span><br><span class="line">HRSRC hRes = <span class="built_in">FindResource</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(bmpId), RT_BITMAP); <span class="comment">// 获取资源句柄</span></span><br><span class="line"><span class="keyword">if</span> (hRes == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s FindResource GetLastError: %d\n&quot;</span>, __FUNCTION__, n);</span><br><span class="line">&#125;</span><br><span class="line">HGLOBAL hMem = <span class="built_in">LoadResource</span>(hInstance, hRes); <span class="comment">// 获取内存句柄</span></span><br><span class="line">LPVOID lpData = <span class="built_in">LockResource</span>(hMem); <span class="comment">// 加载资源数据</span></span><br><span class="line">LPBITMAPINFOHEADER lpBitmapInfoHeader = (LPBITMAPINFOHEADER)lpData; <span class="comment">// 获取位图信息头指针</span></span><br><span class="line">DWORD dwHeight = lpBitmapInfoHeader-&gt;biHeight; <span class="comment">// 获取位图高度</span></span><br><span class="line">DWORD dwWidth = lpBitmapInfoHeader-&gt;biWidth; <span class="comment">// 获取位图宽度</span></span><br><span class="line">DWORD dwColorCount = lpBitmapInfoHeader-&gt;biBitCount &gt;&gt; <span class="number">3</span>; <span class="comment">// 获取位图颜色数</span></span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s dwColorCount: %d\n&quot;</span>, __FUNCTION__, dwColorCount);</span><br><span class="line">dwSize = dwHeight * dwWidth * dwColorCount; <span class="comment">// 计算位图数据大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* pData = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[dwSize]; <span class="comment">// 分配缓存空间</span></span><br><span class="line"><span class="built_in">memcpy</span>(pData, (<span class="type">unsigned</span> <span class="type">char</span>*)lpData + lpBitmapInfoHeader-&gt;biSize + lpBitmapInfoHeader-&gt;biClrUsed * <span class="built_in">sizeof</span>(RGBQUAD), dwSize); <span class="comment">// 拷贝位图数据</span></span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s SizeofResource: %d\n&quot;</span>, __FUNCTION__, dwSize);</span><br><span class="line"><span class="built_in">FreeResource</span>(hMem); <span class="comment">// 释放资源</span></span><br><span class="line"><span class="keyword">return</span> pData;<span class="comment">//返回缓存指针,注意释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目上有需求，要求在提供给第三方的SDK中，将bmp图像一起打包到dll文件中&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>单实例进程的几种实现方式</title>
    <link href="https://yesir.github.io/2023/05/06/%E5%8D%95%E5%AE%9E%E4%BE%8B%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://yesir.github.io/2023/05/06/%E5%8D%95%E5%AE%9E%E4%BE%8B%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2023-05-06T01:29:04.000Z</published>
    <updated>2023-05-06T01:37:13.221Z</updated>
    
    <content type="html"><![CDATA[<p>让进程只运行一个实例,防止多次运行导致的问题</p><span id="more"></span><blockquote><p><code>linux</code>利用文件锁实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">lockfile</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">flock</span> fl;</span><br><span class="line"></span><br><span class="line">    fl.l_type   = F_WRLCK;</span><br><span class="line">    fl.l_start  = <span class="number">0</span>;</span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_len    = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">fcntl</span>(fd, F_SETLK, &amp;fl));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">proc_is_exist</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *procname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">&quot;/tmp/%s.pid&quot;</span>, procname);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(filename, O_RDWR | O_CREAT, (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH));</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file \&quot;%s\&quot; failed!!!\n&quot;</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lockfile</span>(fd) == <span class="number">-1</span>) &#123;                                                  <span class="comment">/* 尝试对文件进行加锁 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file \&quot;%s\&quot; locked. proc already exit!!!\n&quot;</span>, filename);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ftruncate</span>(fd, <span class="number">0</span>);                                                      <span class="comment">/* 写入运行实例的pid */</span></span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%ld&quot;</span>, (<span class="type">long</span>)<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>windows</code>利用内核对象实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hMutex = ::<span class="built_in">CreateMutexA</span>(<span class="literal">NULL</span>, FALSE, <span class="string">&quot;Protected_Mutex_11&quot;</span>);</span><br><span class="line">DWORD dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="keyword">if</span> (ERROR_ALREADY_EXISTS == dwError || ERROR_ACCESS_DENIED == dwError)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 已经有实例了，退出。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Qt</code>复用共享内存实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.h QSharedMemory *m_sharedMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInstanceExisted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_sharedMemory = <span class="keyword">new</span> <span class="built_in">QSharedMemory</span>(<span class="string">&quot;protected-client.lock&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(m_sharedMemory-&gt;<span class="built_in">create</span>(<span class="number">100</span>) == <span class="literal">false</span>) &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;让进程只运行一个实例,防止多次运行导致的问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>用C++获取bmp图像的宽高</title>
    <link href="https://yesir.github.io/2023/04/25/%E7%94%A8C-%E8%8E%B7%E5%8F%96bmp%E5%9B%BE%E5%83%8F%E7%9A%84%E5%AE%BD%E9%AB%98/"/>
    <id>https://yesir.github.io/2023/04/25/%E7%94%A8C-%E8%8E%B7%E5%8F%96bmp%E5%9B%BE%E5%83%8F%E7%9A%84%E5%AE%BD%E9%AB%98/</id>
    <published>2023-04-25T00:55:24.000Z</published>
    <updated>2023-04-25T01:09:20.418Z</updated>
    
    <content type="html"><![CDATA[<p>BMP（Bitmap）是一种位图文件格式，它以二进制方式存储图像数据，即每个像素的颜色信息都被直接编码为一个二进制值。</p><span id="more"></span><blockquote><p>BMP格式的文件由两部分组成：<br>    - 文件头和图像数据。文件头包含了文件类型、文件大小、图像宽度、图像高度等基本信息；<br>    - 图像数据则是按行存储的，每一行的字节数通常等于“宽度×像素位数/8”，其中像素位数指的是每个像素使用的位数<br>      例如24位颜色模式下，每个像素使用3个字节。<br>      在32位BMP图像中，每个像素通常使用4个字节（红色、绿色、蓝色和alpha通道），因此每一行的字节数也会相应增加</p></blockquote><blockquote><p>BMP格式文件头（Bitmap File Header）占据14个字节，其中包含了BMP文件的一些基本信息，如文件类型、文件大小以及图像数据的偏移量等。<br>  文件头结构定义如下：</p></blockquote>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct BITMAPFILEHEADER &#123;</span><br><span class="line"> uint16_t bfType;       // 文件类型，必须为 <span class="string">&quot;BM&quot;</span> 两个字母</span><br><span class="line"> uint32_t bfSize;       // 文件大小，单位为字节</span><br><span class="line"> uint16_t bfReserved1;  // 保留，必须设置为0</span><br><span class="line"> uint16_t bfReserved2;  // 保留，必须设置为0</span><br><span class="line"> uint32_t bfOffBits;    // 图像数据相对于文件头的偏移量，单位为字节</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint16_t 表示16位无符号整数，占据2个字节；uint32_t 表示32位无符号整数，占据4个字节。因此，BMP格式文件头总共占据14个字节的空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>下面是使用C++的标准库来获取bmp图像的宽和高</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;001.bmp&quot;</span>, ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 bmp 文件头信息</span></span><br><span class="line">    <span class="type">char</span> header[<span class="number">54</span>];</span><br><span class="line">    file.<span class="built_in">read</span>(header, <span class="number">54</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取宽度和高度</span></span><br><span class="line">    <span class="type">int</span> width = *(<span class="type">int</span>*)&amp;header[<span class="number">18</span>];</span><br><span class="line">    <span class="type">int</span> height = *(<span class="type">int</span>*)&amp;header[<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line">       <span class="comment">//也可以使用位运算的方式获取，这样可以避免对内存进行类型转换</span></span><br><span class="line">       <span class="comment">//但是在实际存储过程中由于大小端的不同,存储方式可能是倒序的（高字节存储在后面）。</span></span><br><span class="line">       <span class="comment">//因此，在进行位运算时，需要按照实际存储方式进行相应的调整</span></span><br><span class="line">       <span class="comment">//int width = (header[21] &lt;&lt; 24) | (header[20] &lt;&lt; 16) | (header[19] &lt;&lt; 8) | header[18];</span></span><br><span class="line">       <span class="comment">//int height = (header[25] &lt;&lt; 24) | (header[24] &lt;&lt; 16) | (header[23] &lt;&lt; 8) | header[22];</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; pixels&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; height &lt;&lt; <span class="string">&quot; pixels&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;BMP（Bitmap）是一种位图文件格式，它以二进制方式存储图像数据，即每个像素的颜色信息都被直接编码为一个二进制值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>用C++实现类似Windows的消息循环</title>
    <link href="https://yesir.github.io/2023/04/18/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCWindows%E7%9A%84%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF/"/>
    <id>https://yesir.github.io/2023/04/18/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCWindows%E7%9A%84%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF/</id>
    <published>2023-04-18T03:14:42.000Z</published>
    <updated>2023-04-18T03:36:28.724Z</updated>
    
    <content type="html"><![CDATA[<p>实现类似于Windows消息循环的队列</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MessageType</span> &#123; kQuitMessage, kCustomMessage &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="built_in">Message</span>(MessageType t, <span class="type">void</span>* d = <span class="literal">nullptr</span>) : <span class="built_in">type</span>(t), <span class="built_in">data</span>(d) &#123;&#125;</span><br><span class="line">  MessageType type;</span><br><span class="line">  <span class="type">void</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageLoop</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MessageLoop</span>() : <span class="built_in">should_quit_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!should_quit_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (message_queue_.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      Message message = message_queue_.<span class="built_in">front</span>();</span><br><span class="line">      message_queue_.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (message.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kQuitMessage:</span><br><span class="line">          should_quit_ = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCustomMessage:</span><br><span class="line">          <span class="built_in">HandleMessage</span>(message);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Quit</span><span class="params">()</span> </span>&#123; message_queue_.<span class="built_in">push</span>(<span class="built_in">Message</span>(kQuitMessage)); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PostMessage</span><span class="params">(MessageType message_type, <span class="type">void</span>* data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    message_queue_.<span class="built_in">push</span>(<span class="built_in">Message</span>(message_type, data));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">HandleMessage</span><span class="params">(<span class="type">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message_handler_) &#123;</span><br><span class="line">      <span class="built_in">message_handler_</span>(message.type, message.data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetMessageHandler</span><span class="params">(std::function&lt;<span class="type">void</span>(MessageType, <span class="type">void</span>*)&gt; handler)</span> </span>&#123;</span><br><span class="line">    message_handler_ = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> should_quit_;</span><br><span class="line">  std::queue&lt;Message&gt; message_queue_;</span><br><span class="line">  std::function&lt;<span class="type">void</span>(MessageType, <span class="type">void</span>*)&gt; message_handler_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>使用方法：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyClass</span>()&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">MyClass</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;DoSomething...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MessageLoop loop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set message handler function.</span></span><br><span class="line">  loop.<span class="built_in">SetMessageHandler</span>([](MessageType type, <span class="type">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == kCustomMessage) &#123;</span><br><span class="line">      <span class="comment">// Do something with the data, e.g.</span></span><br><span class="line">       MyClass* instance = <span class="built_in">static_cast</span>&lt;MyClass*&gt;(data);</span><br><span class="line">       instance-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post a custom message.</span></span><br><span class="line">  MyClass instance;</span><br><span class="line">  loop.<span class="built_in">PostMessage</span>(kCustomMessage, &amp;instance);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the message loop.</span></span><br><span class="line">  loop.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现类似于Windows消息循环的队列&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu上搭建arm64交叉编译环境</title>
    <link href="https://yesir.github.io/2023/04/03/%E5%9C%A8ubuntu%E4%B8%8A%E6%90%AD%E5%BB%BAarm64%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://yesir.github.io/2023/04/03/%E5%9C%A8ubuntu%E4%B8%8A%E6%90%AD%E5%BB%BAarm64%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</id>
    <published>2023-04-03T01:08:25.000Z</published>
    <updated>2023-04-03T01:27:38.579Z</updated>
    
    <content type="html"><![CDATA[<p>使用环境<code>Ubuntu 20.04.3 LTS</code>,并在系统先安装好<code>Qt</code>,<code>QT Creator</code>开发工具、以及<code>qemu</code>用来加载<code>arm64</code>镜像</p><span id="more"></span><ul><li>安装前准备<ol><li>智能终端OS的rootfs镜像，如：UOS-Smart-20-arm64-src.img</li><li>智能终端OS的qt开发环境及依赖包：qt_deb.tar.gz</li></ol></li></ul><ul><li><p>安装</p><ol><li><p>首先在<code>ubuntu</code>上新建一个空的img文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=UOS-Smart-20-arm64-new.img bs=1M count=7000</span><br><span class="line">sudo mkfs.ext4 UOS-Smart-20-arm64-new.img</span><br></pre></td></tr></table></figure></li><li><p>在<code>ubuntu</code>上新建2个空目录,分别将<code>UOS-Smart-20-arm64-src.img</code>和<code>UOS-Smart-20-arm64-new.img</code>挂载，并把前者的内容拷贝到后者里</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -m 777 src new</span><br><span class="line">sudo mount UOS-Smart-20-arm64-src.img src</span><br><span class="line">sudo mount UOS-Smart-20-arm64-new.img new</span><br><span class="line">sudo <span class="built_in">cp</span> -rfp src/* new/</span><br><span class="line">sudo umount src</span><br></pre></td></tr></table></figure></li><li><p>如果已安装<code>qemu</code>工具，则直接拷贝文件，否则先安装，然后再拷贝所需文件到目标根文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-user-static    <span class="comment">#安装qemu</span></span><br><span class="line">sudo <span class="built_in">cp</span> /usr/bin/qemu-aarch64-static ./new/usr/bin/</span><br><span class="line">sudo <span class="built_in">cp</span> /usr/bin/qemu-arm-static ./new/usr/bin/</span><br><span class="line">sudo <span class="built_in">cp</span> ./new/etc/resolv.conf ./new/etc/resolv.conf.bak</span><br><span class="line">sudo <span class="built_in">cp</span> /etc/resolv.conf ./new/etc/resolv.conf</span><br><span class="line">sudo <span class="built_in">cp</span> qt_deb.tar.gz ./new/home/</span><br></pre></td></tr></table></figure></li><li><p>重新挂载<code>/proc,/dev,/sys</code>节点，然后通过<code>chroot</code>到目标根文件系统中，就进入到了交叉编译环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t proc /proc ./new/proc</span><br><span class="line">sudo mount -t sysfs /sys ./new/sys</span><br><span class="line">sudo mount -o <span class="built_in">bind</span> /dev ./new/dev</span><br><span class="line">sudo <span class="built_in">chroot</span> ./new/</span><br></pre></td></tr></table></figure></li><li><p>在交叉编译环境中安装<code>qt_deb.tar.gz</code>中的所有<code>deb</code>包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar xzf /home/qt_deb.tar.gz</span><br><span class="line">sudo dpkg -i /home/qt_deb/*/deb</span><br></pre></td></tr></table></figure></li></ol></li><li><p>上述步骤安装完成之后，交叉编译环境就搭建完成了。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用环境&lt;code&gt;Ubuntu 20.04.3 LTS&lt;/code&gt;,并在系统先安装好&lt;code&gt;Qt&lt;/code&gt;,&lt;code&gt;QT Creator&lt;/code&gt;开发工具、以及&lt;code&gt;qemu&lt;/code&gt;用来加载&lt;code&gt;arm64&lt;/code&gt;镜像&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://yesir.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++命令模式</title>
    <link href="https://yesir.github.io/2023/03/31/C-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://yesir.github.io/2023/03/31/C-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-03-31T01:32:36.000Z</published>
    <updated>2023-03-31T01:37:16.806Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式的核心在于引入了命令类，通过命令类来降低请求发送者和接收者的耦合度，请求发送者只需要指定一个命令对象，再通过命令对象来调用请求接收者的处理方法</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line">// 命令接口</span><br><span class="line">class Command </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void execute() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 具体命令类1</span><br><span class="line">class ConcreteCommand1 : public Command </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">ConcreteCommand1</span></span>() &#123;&#125;</span><br><span class="line">    void execute() override </span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;执行具体命令1&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 具体命令类2</span></span><br><span class="line"><span class="string">class ConcreteCommand2 : public Command </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    ConcreteCommand2() &#123;&#125;</span></span><br><span class="line"><span class="string">    void execute() override </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">        std</span>::cout &lt;&lt; <span class="string">&quot;执行具体命令2&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 命令调用者</span></span><br><span class="line"><span class="string">class Invoker </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string">    std</span>::vector&lt;Command*&gt; commands_;</span><br><span class="line">public:</span><br><span class="line">    void addCommand(Command* <span class="built_in">command</span>) </span><br><span class="line">&#123;</span><br><span class="line">        commands_.push_back(<span class="built_in">command</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="function"><span class="title">executeCommands</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span> (auto <span class="built_in">command</span> : commands_) </span><br><span class="line">&#123;</span><br><span class="line">            <span class="built_in">command</span>-&gt;execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 命令接收者</span><br><span class="line">class Receiver </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void <span class="function"><span class="title">action</span></span>() </span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;执行命令接收者操作&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 具体命令类3</span></span><br><span class="line"><span class="string">class ConcreteCommand3 : public Command </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string">    Receiver* receiver_;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">    ConcreteCommand3(Receiver* receiver):receiver_(receiver)&#123;&#125;</span></span><br><span class="line"><span class="string">    void execute() override </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">        receiver_-&gt;action();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main(int argc, char* argv[]) </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    Invoker invoker;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 添加具体命令1和2</span></span><br><span class="line"><span class="string">    Command* cmd1 = new ConcreteCommand1();</span></span><br><span class="line"><span class="string">    Command* cmd2 = new ConcreteCommand2();</span></span><br><span class="line"><span class="string">    invoker.addCommand(cmd1);</span></span><br><span class="line"><span class="string">    invoker.addCommand(cmd2);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 添加具体命令3</span></span><br><span class="line"><span class="string">    Receiver* receiver = new Receiver();</span></span><br><span class="line"><span class="string">    Command* cmd3 = new ConcreteCommand3(receiver);</span></span><br><span class="line"><span class="string">    invoker.addCommand(cmd3);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 执行所有命令</span></span><br><span class="line"><span class="string">    invoker.executeCommands();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 释放内存</span></span><br><span class="line"><span class="string">    delete cmd1;</span></span><br><span class="line"><span class="string">    delete cmd2;</span></span><br><span class="line"><span class="string">    delete cmd3;</span></span><br><span class="line"><span class="string">    delete receiver;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Command是命令接口，具有execute方法；</span><br><span class="line">ConcreteCommand1和ConcreteCommand2是具体命令类，实现了execute方法，分别对应不同的具体操作；</span><br><span class="line">Invoker是命令调用者，可以添加多个命令，并按顺序执行；</span><br><span class="line">Receiver是命令接收者，具有实际的操作方法；</span><br><span class="line">ConcreteCommand3是具体命令类，将命令接收者作为参数传递进去，在execute方法中调用接收者的操作方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行该程序会输出以下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行具体命令1</span><br><span class="line">执行具体命令2</span><br><span class="line">执行命令接收者操作</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;命令模式的核心在于引入了命令类，通过命令类来降低请求发送者和接收者的耦合度，请求发送者只需要指定一个命令对象，再通过命令对象来调用请求接收者的处理方法&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>opencv学习（四）</title>
    <link href="https://yesir.github.io/2023/03/27/opencv%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://yesir.github.io/2023/03/27/opencv%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2023-03-27T02:47:13.000Z</published>
    <updated>2023-03-27T02:51:12.866Z</updated>
    
    <content type="html"><![CDATA[<p>OpenCV库打开摄像头并保存视频,只能保存为<code>avi</code>格式，最大保存文件大小为2Gb</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;opencv2/opencv.hpp&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    VideoCapture <span class="built_in">cap</span>(0); // 打开默认的摄像头设备</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cap.isOpened()) // 检查是否成功打开</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法打开摄像头&quot;</span> &lt;&lt; <span class="string">endl;</span></span><br><span class="line"><span class="string">        return -1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int frame_width = cap.get(CAP_PROP_FRAME_WIDTH);</span></span><br><span class="line"><span class="string">    int frame_height = cap.get(CAP_PROP_FRAME_HEIGHT);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Size frame_size(frame_width, frame_height);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    VideoWriter video(&quot;output.avi&quot;, VideoWriter::fourcc(&#x27;M&#x27;, &#x27;J&#x27;, &#x27;P&#x27;, &#x27;G&#x27;), 10, frame_size); //保存视频文件为output.avi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (!video.isOpened())</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot;无法创建视频文件&quot; &lt;&lt; endl</span>;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat frame;</span><br><span class="line"></span><br><span class="line">        bool success = cap.read(frame); // 读取一帧图像</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success) // 如果读取失败则退出循环</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        video.write(frame); // 写入视频文件</span><br><span class="line"></span><br><span class="line">        imshow(<span class="string">&quot;Camera&quot;</span>, frame); // 显示当前帧图像</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitKey(25) == 27) // 等待按键，如果按下ESC键则退出循环</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cap.release(); // 释放摄像头</span><br><span class="line">    video.release(); // 关闭视频文件</span><br><span class="line"></span><br><span class="line">    destroyAllWindows(); // 关闭所有窗口</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenCV库打开摄像头并保存视频,只能保存为&lt;code&gt;avi&lt;/code&gt;格式，最大保存文件大小为2Gb&lt;/p&gt;</summary>
    
    
    
    
    <category term="Opencv" scheme="https://yesir.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>用C++实现事件监听器</title>
    <link href="https://yesir.github.io/2023/03/16/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://yesir.github.io/2023/03/16/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2023-03-16T06:18:50.000Z</published>
    <updated>2023-03-16T06:26:35.337Z</updated>
    
    <content type="html"><![CDATA[<p>事件监听器是一种常见的设计模式，用于在对象之间建立一种松耦合的关系，当某个对象发生特定事件时，可以通知所有注册了该事件的监听器对象。</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;functional&gt;</span></span><br><span class="line"><span class="comment">#include &lt;mutex&gt;</span></span><br><span class="line"><span class="comment">#include &lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">class EventListener &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~<span class="function"><span class="title">EventListener</span></span>() &#123;&#125;</span><br><span class="line">    virtual void HandleEvent(int eventId) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class EventSource &#123;</span><br><span class="line">public:</span><br><span class="line">    void RegisterListener(EventListener* listener) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</span><br><span class="line">        m_listeners.push_back(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void UnregisterListener(EventListener* listener) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</span><br><span class="line">        <span class="keyword">for</span> (auto it = m_listeners.begin(); it != m_listeners.end(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it == listener) &#123;</span><br><span class="line">                m_listeners.erase(it);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void NotifyListeners(int eventId) &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</span><br><span class="line">        <span class="keyword">for</span> (auto listener : m_listeners) &#123;</span><br><span class="line">            std::thread t(std::<span class="built_in">bind</span>(&amp;EventListener::HandleEvent, listener, eventId));</span><br><span class="line">            t.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;EventListener*&gt; m_listeners;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyListener : public EventListener &#123;</span><br><span class="line">public:</span><br><span class="line">    void HandleEvent(int eventId) override &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyListener: received event &quot;</span> &lt;&lt; <span class="string">eventId &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[]) </span><br><span class="line">&#123;</span><br><span class="line">    EventSource <span class="built_in">source</span>;</span><br><span class="line">    MyListener listener1;</span><br><span class="line">    MyListener listener2;</span><br><span class="line"></span><br><span class="line">    source.RegisterListener(&amp;listener1);</span><br><span class="line">    source.RegisterListener(&amp;listener2);</span><br><span class="line"></span><br><span class="line">    source.NotifyListeners(1);</span><br><span class="line"></span><br><span class="line">    source.UnregisterListener(&amp;listener2);</span><br><span class="line"></span><br><span class="line">    source.NotifyListeners(2);</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventListener表示事件监听器抽象类，其中包含一个HandleEvent方法用于处理事件。<br>EventSource表示事件源，其中包含一个RegisterListener方法用于注册监听器、一个UnregisterListener方法用于注销监听器，<br>以及一个NotifyListeners方法用于通知所有注册的监听器。<br>在NotifyListeners方法中，我们使用std::thread创建了一个新线程，并在其中调用HandleEvent方法处理事件。</p><p>在main函数中，我们创建了一个EventSource对象和两个MyListener对象，并通过RegisterListener方法将它们注册到事件源中。<br>然后,我们通过NotifyListeners方法发送了一个事件1，并观察到两个监听器都收到了事件。<br>接着，我们通过UnregisterListener方法将一个监听器注销掉，再次发送了一个事件2，并观察到只有一个监听器收到了事件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;事件监听器是一种常见的设计模式，用于在对象之间建立一种松耦合的关系，当某个对象发生特定事件时，可以通知所有注册了该事件的监听器对象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>在linux下实现类似WaitForSingleObjectEx功能</title>
    <link href="https://yesir.github.io/2023/03/16/%E5%9C%A8linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCWaitForSingleObjectEx%E5%8A%9F%E8%83%BD/"/>
    <id>https://yesir.github.io/2023/03/16/%E5%9C%A8linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCWaitForSingleObjectEx%E5%8A%9F%E8%83%BD/</id>
    <published>2023-03-16T06:12:06.000Z</published>
    <updated>2023-04-06T07:19:59.600Z</updated>
    
    <content type="html"><![CDATA[<p>利用pthread_cond_t在实现等待线程完成或超时，来达到类似WaitForSingleObjectEx的功能。</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define WAIT_TIMEOUT ETIMEDOUT</span></span><br><span class="line"><span class="comment">#define WAIT_OBJECT_0 0</span></span><br><span class="line"></span><br><span class="line">void* ThreadFunc(void* args)</span><br><span class="line">&#123;</span><br><span class="line">    // 等待 3 秒钟模拟子线程工作</span><br><span class="line">    <span class="built_in">sleep</span>(3);</span><br><span class="line"></span><br><span class="line">    // 发送条件变量信号通知主线程完成</span><br><span class="line">    pthread_cond_t* cond = (pthread_cond_t*)args;</span><br><span class="line">    pthread_cond_signal(cond);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用条件变量模拟 WaitForSingleObjectEx</span><br><span class="line">int WaitForSingleObjectEx(pthread_mutex_t* mutex, pthread_cond_t* cond, int timeout_ms) </span><br><span class="line">&#123;</span><br><span class="line">    struct timespec ts;</span><br><span class="line">    clock_gettime(CLOCK_REALTIME, &amp;ts);</span><br><span class="line">    ts.tv_sec += timeout_ms / 1000;</span><br><span class="line">    ts.tv_nsec += (timeout_ms % 1000) * 1000000;</span><br><span class="line"></span><br><span class="line">    // 加锁并等待条件变量</span><br><span class="line">    pthread_mutex_lock(mutex);</span><br><span class="line">    int ret = pthread_cond_timedwait(cond, mutex, &amp;ts);</span><br><span class="line">    pthread_mutex_unlock(mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == ETIMEDOUT) &#123;</span><br><span class="line">        <span class="built_in">return</span> WAIT_TIMEOUT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> WAIT_OBJECT_0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在主线程中使用条件变量等待子线程完成</span><br><span class="line">int main(int argc, char* argv[]) </span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line">    // 创建子线程</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    pthread_create(&amp;tid, NULL, ThreadFunc, &amp;cond);</span><br><span class="line"></span><br><span class="line">    // 等待子线程完成或超时</span><br><span class="line">    int ret = WaitForSingleObjectEx(&amp;mutex, &amp;cond, 5000);</span><br><span class="line">    <span class="keyword">if</span> (ret == WAIT_OBJECT_0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread completed successfully.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Timeout waiting for thread.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 销毁条件变量和互斥锁</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> 0</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="另外一种实现方式"><a href="#另外一种实现方式" class="headerlink" title="另外一种实现方式"></a>另外一种实现方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用C++11中提供的std::condition_variable来实现等待和通知，使用std::mutex来保证线程安全，使用std::chrono来保证可以设置超时时间。</span><br><span class="line">主要的思路是定义了一个Event类，通过该类中的Set、Reset和Wait函数来设置信号量、重置信号量和等待信号量。</span><br><span class="line">CreateEvent函数返回的是Event类的实例指针，即同等于Windows中的事件句柄，</span><br><span class="line">CloseHandle函数用于清除该指针所代表的资源，在本代码中即清除Event类的实例。</span><br><span class="line">WaitForSingleObjectEx函数则是调用该事件实例所定义的Wait函数，实现等待信号量和设置超时时间的功能。</span><br></pre></td></tr></table></figure><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> DWORD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* HANDLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">WAIT_RETURN</span> &#123;</span><br><span class="line">    WAIT_OBJECT_0 = <span class="number">0x00000000</span>L,</span><br><span class="line">    WAIT_ABANDONED = <span class="number">0x00000080</span>L,</span><br><span class="line">    WAIT_TIMEOUT = <span class="number">0x00000102</span>L,</span><br><span class="line">    WAIT_IO_COMPLETION = <span class="number">0x000000C0</span>L,</span><br><span class="line">    WAIT_FAILED = <span class="number">0xFFFFFFFF</span>L</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Event</span>() : <span class="built_in">signaled_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        signaled_ = <span class="literal">true</span>;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        signaled_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DWORD <span class="title">Wait</span><span class="params">(DWORD timeout = INFINITE)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout == INFINITE) &#123;</span><br><span class="line">            cv_.<span class="built_in">wait</span>(lock, [&amp;] &#123; <span class="keyword">return</span> signaled_; &#125;);</span><br><span class="line">            <span class="keyword">return</span> WAIT_OBJECT_0;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> result = cv_.<span class="built_in">wait_for</span>(lock, std::chrono::<span class="built_in">milliseconds</span>(timeout), [&amp;] &#123; <span class="keyword">return</span> signaled_; &#125;);</span><br><span class="line">            <span class="keyword">if</span> (result == std::cv_status::timeout) &#123;</span><br><span class="line">                <span class="keyword">return</span> WAIT_TIMEOUT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> WAIT_OBJECT_0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    <span class="type">bool</span> signaled_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(<span class="type">void</span>* lpEventAttributes, <span class="type">bool</span> bManualReset, <span class="type">bool</span> bInitialState,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">char</span>* lpName)</span> </span>&#123;</span><br><span class="line">    Event* event = <span class="keyword">new</span> <span class="built_in">Event</span>();</span><br><span class="line">    <span class="keyword">if</span> (bInitialState) &#123;</span><br><span class="line">        event-&gt;<span class="built_in">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;HANDLE&gt;(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(HANDLE hObject)</span> </span>&#123;</span><br><span class="line">    Event* event = <span class="built_in">static_cast</span>&lt;Event*&gt;(hObject);</span><br><span class="line">    <span class="keyword">delete</span> event;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObjectEx</span><span class="params">(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)</span> </span>&#123;</span><br><span class="line">    Event* event = <span class="built_in">static_cast</span>&lt;Event*&gt;(hHandle);</span><br><span class="line">    <span class="keyword">return</span> event-&gt;<span class="built_in">Wait</span>(dwMilliseconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用pthread_cond_t在实现等待线程完成或超时，来达到类似WaitForSingleObjectEx的功能。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>使用C++11创建简易环形队列</title>
    <link href="https://yesir.github.io/2023/03/14/%E4%BD%BF%E7%94%A8C-11%E5%88%9B%E5%BB%BA%E7%AE%80%E6%98%93%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/"/>
    <id>https://yesir.github.io/2023/03/14/%E4%BD%BF%E7%94%A8C-11%E5%88%9B%E5%BB%BA%E7%AE%80%E6%98%93%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97/</id>
    <published>2023-03-14T06:23:49.000Z</published>
    <updated>2023-03-14T06:29:47.344Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>std::vector</code>来实现环形队列</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class RingBuffer &#123;</span><br><span class="line">public:</span><br><span class="line">    RingBuffer(size_t capacity) : buffer(capacity), begin(0), end(0), size(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const T &amp;value) &#123;</span><br><span class="line">        buffer[end] = value;</span><br><span class="line">        end = (end + 1) % buffer.size();</span><br><span class="line">        <span class="keyword">if</span> (size == buffer.size()) &#123;</span><br><span class="line">            begin = (begin + 1) % buffer.size();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const T&amp; operator[](size_t index) const &#123;</span><br><span class="line">        <span class="built_in">return</span> buffer[(begin + index) % buffer.size()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t getSize() const &#123;</span><br><span class="line">        <span class="built_in">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;T&gt; buffer;</span><br><span class="line">    size_t begin, end, size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由<code>std::vector</code>存储元素，三个成员变量begin、end和size分别表示队列的起始位置、结束位置和元素数量.<br><code>push_back</code>方法可以将新元素添加到队列尾部，并根据队列是否已满更新起止位置和元素数量.<br>可以通过下标访问队列中的元素.<br><code>getSize</code>方法可以返回队列中元素的数量.</p><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RingBuffer&lt;int&gt; ringBuffer(10);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">    ringBuffer.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (size_t i = 0; i &lt; ringBuffer.getSize(); i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">ringBuffer[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// 输出：10 11 12 13 14 15 16 17 18 19</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>创建一个容量为10的整型环形队列，向其中添加了20个元素。由于队列容量有限，只能保留最后10个元素。<br>最后通过下标访问队列中的元素，并输出结果</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用&lt;code&gt;std::vector&lt;/code&gt;来实现环形队列&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++单例模式模板类</title>
    <link href="https://yesir.github.io/2023/03/09/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF%E7%B1%BB/"/>
    <id>https://yesir.github.io/2023/03/09/C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%9D%BF%E7%B1%BB/</id>
    <published>2023-03-09T00:41:59.000Z</published>
    <updated>2023-03-09T00:54:29.381Z</updated>
    
    <content type="html"><![CDATA[<p>记录C++单例模式，模板方法类</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef SINGLETON_HPP</span></span><br><span class="line"><span class="comment">#define SINGLETON_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdexcept&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define NON_COPYABLE(T) \</span></span><br><span class="line">  T(const T &amp;); \</span><br><span class="line">  T &amp;operator=(const T &amp;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#define NON_MOVEABLE(T) \</span></span><br><span class="line">  T(T &amp;&amp;); \</span><br><span class="line">  T &amp;operator=(T &amp;&amp;)</span><br><span class="line"></span><br><span class="line">template&lt; typename T &gt;</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">  static T *_ptr;</span><br><span class="line">  </span><br><span class="line">  NON_COPYABLE(Singleton);</span><br><span class="line">  NON_MOVEABLE(Singleton);</span><br><span class="line">  </span><br><span class="line">public:</span><br><span class="line">  template&lt; typename... Args &gt;</span><br><span class="line">  static void createInstance(Args&amp;&amp;... args)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ptr)</span><br><span class="line">      <span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    _ptr = new T(std::forward&lt; Args &gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static void <span class="function"><span class="title">deleteInstance</span></span>()</span><br><span class="line">  &#123;</span><br><span class="line">    delete _ptr;</span><br><span class="line">    _ptr = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static bool <span class="function"><span class="title">hasInstance</span></span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">return</span> _ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static T &amp;<span class="function"><span class="title">instance</span></span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_ptr)</span><br><span class="line">      throw std::runtime_error(<span class="string">&quot;Singleton&lt; T &gt;::createInstance missing&quot;</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">return</span> *_ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Singleton &amp;operator==(const Singleton &amp;) = delete;</span><br><span class="line">  Singleton &amp;operator==(Singleton &amp;&amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename T &gt; T *Singleton&lt; T &gt;::_ptr = nullptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define CREATE_INSTANCE(T, ...) Singleton&lt; T &gt;::createInstance(__VA_ARGS__)</span></span><br><span class="line"><span class="comment">#define DELETE_INSTANCE(T, ...) Singleton&lt; T &gt;::deleteInstance()</span></span><br><span class="line"><span class="comment">#define INSTANCE(T) Singleton&lt; T &gt;::instance()</span></span><br><span class="line"><span class="comment">#define HAS_INSTANCE(T) Singleton&lt; T &gt;::hasInstance()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">explicit A();</span><br><span class="line">public:</span><br><span class="line">void get();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">CREATE_INSTANCE(A);</span><br><span class="line">INSTANCE(A).get();</span><br><span class="line">    DELETE_INSTANCE(A);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录C++单例模式，模板方法类&lt;/p&gt;</summary>
    
    
    
    
    <category term="C/C++" scheme="https://yesir.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>QtConcurrent引发的崩溃</title>
    <link href="https://yesir.github.io/2023/02/21/QtConcurrent%E5%BC%95%E5%8F%91%E7%9A%84%E5%B4%A9%E6%BA%83/"/>
    <id>https://yesir.github.io/2023/02/21/QtConcurrent%E5%BC%95%E5%8F%91%E7%9A%84%E5%B4%A9%E6%BA%83/</id>
    <published>2023-02-21T09:17:12.000Z</published>
    <updated>2023-02-21T09:34:23.773Z</updated>
    
    <content type="html"><![CDATA[<p>使用QtConcurrent创建线程的一些问题总结</p><span id="more"></span><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在.h文件中定义了：</span><br><span class="line">QFuture&lt;int&gt; m_iFuture;</span><br><span class="line">int funcionProc();</span><br><span class="line"></span><br><span class="line">在源文件中：</span><br><span class="line">m_iFuture = QtConcurrent::run(this, &amp;ClassName::functionProc);</span><br><span class="line"></span><br><span class="line">int ClassName::<span class="function"><span class="title">functionProc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!isExit())</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>* 注：由于使用`QtConcurrent::run`创建的线程不能使用`m_iFuture`暂停和取消，只能查询运行状态及完成返回值，因此上面的代码，如果在外面设置`isExit()==true`时，在不同的Qt版本会崩溃* 原因是线程执行函数一直得不到返回值, 需要在`functionProc`中添加`return`语句。* 附打开摄像头代码</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef CAMERA_H</span></span><br><span class="line"><span class="comment">#define CAMERA_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;QDialog&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QMutex&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QFuture&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QPixmap&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QSize&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QThread&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;opencv2/opencv.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/core.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/highgui.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/videoio.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/imgproc.hpp&quot;</span></span><br><span class="line"></span><br><span class="line">class Camera : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Camera(QObject *parent = 0);</span><br><span class="line">    ~Camera();</span><br><span class="line"></span><br><span class="line">    bool open();</span><br><span class="line">    void close();</span><br><span class="line">    bool isAvailable();</span><br><span class="line">    bool isOpened();</span><br><span class="line"></span><br><span class="line">    cv::Mat getCurrentFrame();</span><br><span class="line">private:</span><br><span class="line">     bool needStopFrameProc();</span><br><span class="line">     void setStopFrameProc(bool stopFlag);</span><br><span class="line">     int frameProc();</span><br><span class="line">     void setCurrentFrame(const cv::Mat&amp; frame);</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    void frameCaptured(QPixmap pixmap);</span><br><span class="line">    void cameraStateChanged(QString);</span><br><span class="line">private:</span><br><span class="line">    cv::VideoCapture* m_videoCapture;</span><br><span class="line"></span><br><span class="line">    bool m_stopFrameProc;</span><br><span class="line">    QMutex m_frameProcMutex;</span><br><span class="line">    QFuture&lt;int&gt; m_frameProcFuture;</span><br><span class="line"></span><br><span class="line">    QMutex m_currentFrameMutex;</span><br><span class="line">    cv::Mat m_currentFrame;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#endif // CAMERA_H</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;Camera.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;libudev.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;inttypes.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ioctl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/videodev2.h&gt;//v4l2相关结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;opencv2/opencv.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/core.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/highgui.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/videoio.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &quot;opencv2/imgproc.hpp&quot;</span></span><br><span class="line"><span class="comment">#include &lt;QtMultimedia/QCameraInfo&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QMessageBox&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QMutexLocker&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QtConcurrent&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QImage&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;map&gt;</span></span><br><span class="line"><span class="comment">#include &lt;QDebug&gt;</span></span><br><span class="line"></span><br><span class="line">using std::string;</span><br><span class="line"></span><br><span class="line">static const int CAMERA_WIDTH = 640;</span><br><span class="line">static const int CAMERA_HEIGHT = 480;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define udev_list_entry_foreach(entry, first) \</span></span><br><span class="line">    <span class="keyword">for</span> (entry = first; \</span><br><span class="line">         entry != NULL; \</span><br><span class="line">         entry = udev_list_entry_get_next(entry))</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    string vid;</span><br><span class="line">    string pid;</span><br><span class="line">&#125; VPID;</span><br><span class="line"></span><br><span class="line">std::map&lt;string, string&gt; g_pidandpath;</span><br><span class="line"></span><br><span class="line">int v4l2_is_v4l_dev(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> !strncmp(name, <span class="string">&quot;video&quot;</span>, 5) || !strncmp(name, <span class="string">&quot;radio&quot;</span>, 5) || !strncmp(name, <span class="string">&quot;vbi&quot;</span>, 3) || !strncmp(name, <span class="string">&quot;v4l-subdev&quot;</span>, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool read_vpid(string dev_path, VPID&amp; vpid)</span><br><span class="line">&#123;</span><br><span class="line">    bool success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    auto udev = udev_new();</span><br><span class="line">    <span class="keyword">if</span> (!udev) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct <span class="built_in">stat</span> statbuf;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(dev_path.c_str(), &amp;statbuf) &lt; 0) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto <span class="built_in">type</span> =  S_ISBLK(statbuf.st_mode) ? <span class="string">&#x27;b&#x27;</span> : S_ISCHR(statbuf.st_mode) ? <span class="string">&#x27;c&#x27;</span> : 0;</span><br><span class="line"></span><br><span class="line">    auto opened_dev = udev_device_new_from_devnum(udev, <span class="built_in">type</span>, statbuf.st_rdev);</span><br><span class="line">    auto dev = opened_dev;</span><br><span class="line"></span><br><span class="line">    struct udev_list_entry *list_entry;</span><br><span class="line">    udev_list_entry_foreach(list_entry, udev_device_get_properties_list_entry(dev))</span><br><span class="line">    &#123;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(strcmp(udev_list_entry_get_name(list_entry), <span class="string">&quot;ID_VENDOR_ID&quot;</span>) == 0)</span><br><span class="line">            vpid.vid = udev_device_get_property_value(dev, udev_list_entry_get_name(list_entry));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strcmp(udev_list_entry_get_name(list_entry), <span class="string">&quot;ID_MODEL_ID&quot;</span>) == 0)</span><br><span class="line">            vpid.pid = udev_device_get_property_value(dev, udev_list_entry_get_name(list_entry));</span><br><span class="line"></span><br><span class="line">        //printf(<span class="string">&quot;==== vid: %s\n pid: %s\n&quot;</span>, vpid.vid.c_str(), vpid.pid.c_str());</span><br><span class="line">        /*<span class="built_in">printf</span>(<span class="string">&quot;%s=%s\n&quot;</span>, udev_list_entry_get_name(list_entry), udev_list_entry_get_value(list_entry));*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*<span class="keyword">while</span> (dev != nullptr) &#123;</span><br><span class="line">        auto serial = udev_device_get_sysattr_value(dev, <span class="string">&quot;serial&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (nullptr == serial) &#123;</span><br><span class="line">            dev = udev_device_get_parent(dev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            vpid.vid = udev_device_get_sysattr_value(dev, <span class="string">&quot;idVendor&quot;</span>);</span><br><span class="line">            vpid.pid = udev_device_get_sysattr_value(dev, <span class="string">&quot;idProduct&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;==== vid: %s\n pid: %s\n&quot;</span>, vpid.vid.c_str(), vpid.pid.c_str());</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*/</span><br><span class="line">    <span class="keyword">if</span> (opened_dev) &#123;</span><br><span class="line">        udev_device_unref(opened_dev);</span><br><span class="line">    &#125;</span><br><span class="line">    udev_unref(udev);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool get_camera_path(string &amp;camera_path)</span><br><span class="line">&#123;</span><br><span class="line">    bool success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    const char* dir_name = <span class="string">&quot;/dev&quot;</span>;</span><br><span class="line">    DIR* <span class="built_in">dir</span> = opendir(dir_name);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dir</span>) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">&quot;Error: couldn&#x27;t open the directory: %s\n&quot;</span>, dir_name);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct dirent* entry = nullptr;</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(<span class="built_in">dir</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v4l2_is_v4l_dev(entry-&gt;d_name))</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">        char device_name[256];</span><br><span class="line">        snprintf(device_name, sizeof(device_name), <span class="string">&quot;/dev/%s&quot;</span>, entry-&gt;d_name);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((fd = open(device_name, O_RDWR | O_NONBLOCK)) &lt; 0) &#123;</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        struct v4l2_capability <span class="built_in">cap</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, VIDIOC_QUERYCAP, &amp;<span class="built_in">cap</span>) &lt; 0) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">&quot;Error: cam_info: can&#x27;t open device: %s\n&quot;</span>, device_name);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="keyword">if</span>(!(cap.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE) || !(cap.capabilities &amp; V4L2_CAP_STREAMING)) &#123;                </span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                //printf(<span class="string">&quot;Driver Name:%s\n Card Name:%s\n Bus info:%s\n version:%d\n capabilities:%x\n \n &quot;</span>, cap.driver, cap.card, cap.bus_info,cap.version,cap.capabilities);</span><br><span class="line">                camera_path = device_name;</span><br><span class="line">                VPID vid;</span><br><span class="line">                <span class="keyword">if</span>(read_vpid(device_name, vid))</span><br><span class="line">                &#123;</span><br><span class="line">                    g_pidandpath[vid.pid] = device_name;</span><br><span class="line">                &#125;</span><br><span class="line">                close(fd);</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">//                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(<span class="built_in">dir</span>);</span><br><span class="line">    <span class="built_in">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Camera::Camera(QObject *parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_stopFrameProc = <span class="literal">false</span>;</span><br><span class="line">    m_videoCapture = new cv::VideoCapture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Camera::~<span class="function"><span class="title">Camera</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    delete m_videoCapture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Camera::<span class="function"><span class="title">open</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_frameProcFuture.isRunning()) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setStopFrameProc(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string cameraPath;</span><br><span class="line">    <span class="keyword">if</span>(!::get_camera_path(cameraPath))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not find vis path!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool cameraOpened;</span><br><span class="line">    <span class="keyword">for</span>(std::map&lt;string, string&gt;::iterator it = g_pidandpath.begin(); it != g_pidandpath.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(strncmp(it-&gt;first.c_str(), <span class="string">&quot;ae01&quot;</span>, 4) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            cameraOpened = m_videoCapture-&gt;open(it-&gt;second);</span><br><span class="line">            //printf(<span class="string">&quot;====== %s, cameraOpened: %d\n&quot;</span>, it-&gt;second.c_str(), cameraOpened);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //bool cameraOpened = m_videoCapture-&gt;open(cameraPath);</span><br><span class="line">    //printf(<span class="string">&quot;====== %s, cameraOpened: %d\n&quot;</span>, cameraPath.c_str(), cameraOpened);</span><br><span class="line">    <span class="keyword">if</span>(cameraOpened) &#123;</span><br><span class="line">        m_videoCapture-&gt;<span class="built_in">set</span>(CV_CAP_PROP_FPS, 15);</span><br><span class="line">        m_videoCapture-&gt;<span class="built_in">set</span>(CV_CAP_PROP_FRAME_WIDTH, CAMERA_WIDTH);</span><br><span class="line">        m_videoCapture-&gt;<span class="built_in">set</span>(CV_CAP_PROP_FRAME_HEIGHT, CAMERA_HEIGHT);</span><br><span class="line">        m_videoCapture-&gt;<span class="built_in">set</span>(CV_CAP_PROP_FOURCC, CV_FOURCC(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;G&#x27;</span>));</span><br><span class="line"></span><br><span class="line">        m_frameProcFuture = QtConcurrent::run(this, &amp;Camera::frameProc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> cameraOpened;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Camera::<span class="function"><span class="title">close</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_frameProcFuture.isRunning())</span><br><span class="line">    &#123;</span><br><span class="line">        setStopFrameProc(<span class="literal">true</span>);</span><br><span class="line">        m_frameProcFuture.waitForFinished();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m_videoCapture-&gt;release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Camera::<span class="function"><span class="title">isAvailable</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    string cameraPath;</span><br><span class="line">    <span class="keyword">if</span>(!::get_camera_path(cameraPath))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not find vis path!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool cameraOpened = m_videoCapture-&gt;open(cameraPath);</span><br><span class="line">    <span class="keyword">if</span>(cameraOpened) &#123;</span><br><span class="line">        m_videoCapture-&gt;release();</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Camera::<span class="function"><span class="title">isOpened</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> m_videoCapture-&gt;isOpened();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Camera::<span class="function"><span class="title">needStopFrameProc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    QMutexLocker locker(&amp;m_frameProcMutex);</span><br><span class="line">    //qDebug() &lt;&lt; <span class="string">&quot;needStopFrameProc: &quot;</span> &lt;&lt; <span class="string">m_stopFrameProc;</span></span><br><span class="line"><span class="string">    return m_stopFrameProc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Camera::setStopFrameProc(bool stopFlag)</span><br><span class="line">&#123;</span><br><span class="line">    QMutexLocker locker(&amp;m_frameProcMutex);</span><br><span class="line">    //qDebug() &lt;&lt; <span class="string">&quot;setStopFrameProc: &quot;</span> &lt;&lt; <span class="string">stopFlag;</span></span><br><span class="line"><span class="string">    m_stopFrameProc = stopFlag</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 通过调试发现，当摄像头断开后，每次<span class="built_in">read</span>()虽然返回的还是<span class="literal">true</span>，Mat也不是empty，但是Mat的数据都是上一次的数据，</span><br><span class="line">* 于是推测可以通过直接判断Mat的内容来判断摄像头是否正常。经过调试发现摄像头断开时Mat的数据的确是初始状态的。于是可以通过检测<span class="built_in">read</span>()后的Mat来判断摄像头是否正常：</span><br><span class="line">*/</span><br><span class="line">bool checkMat(cv::Mat&amp; mat)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; mat.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">uchar* pRow = (unsigned char*)mat.ptr&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (int j = 0; j &lt; mat.cols * mat.channels(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pRow[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* 在正常状态下，这个判断是很快的，所有这个判断可以在每一帧的后面使用。当然，这个要求Mat每次都得初始化。</span><br><span class="line">*</span><br><span class="line">* cv::Mat m;</span><br><span class="line">* <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">* &#123;</span><br><span class="line">*    m.release();</span><br><span class="line">*    m_v.read(m);</span><br><span class="line">*    <span class="keyword">if</span> (!checkMat(frame))</span><br><span class="line">*    &#123;</span><br><span class="line">*        LOG(<span class="string">&quot;摄像头断开\n&quot;</span>);</span><br><span class="line">*        m_v.release();</span><br><span class="line">*    &#125;</span><br><span class="line">*    ...</span><br><span class="line">* &#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int Camera::<span class="function"><span class="title">frameProc</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    struct timeval <span class="built_in">timeout</span>;</span><br><span class="line">    timeout.tv_sec = 0;</span><br><span class="line">    timeout.tv_usec = 1000*100;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!needStopFrameProc()) &#123;</span><br><span class="line">        usleep(50*1000);</span><br><span class="line"></span><br><span class="line">        cv::Mat rawFrame;</span><br><span class="line">        *m_videoCapture &gt;&gt; rawFrame;</span><br><span class="line">        <span class="keyword">if</span> (!checkMat(rawFrame))</span><br><span class="line">            emit cameraStateChanged(<span class="string">&quot;摄像头断开, 请重试&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rawFrame.empty()) &#123;</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setCurrentFrame(rawFrame);</span><br><span class="line"></span><br><span class="line">            cv::Mat frame;</span><br><span class="line">            //显示可见光摄像头</span><br><span class="line">            cv::cvtColor(rawFrame, frame, cv::COLOR_RGB2BGR);</span><br><span class="line"></span><br><span class="line">            const uchar* data = (const uchar*) frame.data;</span><br><span class="line">            QImage image(data, frame.cols, frame.rows, frame.step, QImage::Format_RGB888);</span><br><span class="line">            QPixmap pixmap = QPixmap::fromImage(image);</span><br><span class="line"></span><br><span class="line">            emit frameCaptured(pixmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::Mat Camera::<span class="function"><span class="title">getCurrentFrame</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    QMutexLocker locker(&amp;m_currentFrameMutex);</span><br><span class="line">    <span class="built_in">return</span> m_currentFrame.<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Camera::setCurrentFrame(const cv::Mat &amp;frame)</span><br><span class="line">&#123;</span><br><span class="line">    QMutexLocker locker(&amp;m_currentFrameMutex);</span><br><span class="line">    m_currentFrame = frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用QtConcurrent创建线程的一些问题总结&lt;/p&gt;</summary>
    
    
    
    
    <category term="随笔" scheme="https://yesir.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>在aarch64麒麟V10上编译qt-5.9.8</title>
    <link href="https://yesir.github.io/2023/02/15/%E5%9C%A8aarch64%E9%BA%92%E9%BA%9FV10%E4%B8%8A%E7%BC%96%E8%AF%91qt-5-9-8/"/>
    <id>https://yesir.github.io/2023/02/15/%E5%9C%A8aarch64%E9%BA%92%E9%BA%9FV10%E4%B8%8A%E7%BC%96%E8%AF%91qt-5-9-8/</id>
    <published>2023-02-15T07:55:00.000Z</published>
    <updated>2023-03-21T00:39:35.458Z</updated>
    
    <content type="html"><![CDATA[<p>记录在麒麟V10<code>aarch64/Phytium,FT-2000/4</code>上编译<code>Qt-5.9.8</code></p><span id="more"></span><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   Linux kylinsec-FT2004 5.4.18-52-generic <span class="comment">#41 SMP Wed Mar 2 15:24:07 CST 2022 aarch64 aarch64 aarch64 GNU/Linux</span></span><br><span class="line"></span><br><span class="line">架构：                           aarch64</span><br><span class="line">CPU 运行模式：                   32-bit, 64-bit</span><br><span class="line">字节序：                         Little Endian</span><br><span class="line">CPU:                             4</span><br><span class="line">在线 CPU 列表：                  0-3</span><br><span class="line">每个核的线程数：                 1</span><br><span class="line">每个座的核数：                   2</span><br><span class="line">座：                             2</span><br><span class="line">NUMA 节点：                      1</span><br><span class="line">厂商 ID：                        0x70</span><br><span class="line">型号：                           3</span><br><span class="line">型号名称：                       Phytium,FT-2000/4</span><br><span class="line">步进：                           0x1</span><br><span class="line">BogoMIPS：                       96.00</span><br><span class="line">NUMA 节点0 CPU：                 0-3</span><br><span class="line">Vulnerability Itlb multihit:     Not affected</span><br><span class="line">Vulnerability L1tf:              Not affected</span><br><span class="line">Vulnerability Mds:               Not affected</span><br><span class="line">Vulnerability Meltdown:          Vulnerable</span><br><span class="line">Vulnerability Spec store bypass: Not affected</span><br><span class="line">Vulnerability Spectre v1:        Mitigation; __user pointer sanitization</span><br><span class="line">Vulnerability Spectre v2:        Not affected</span><br><span class="line">Vulnerability Tsx async abort:   Not affected</span><br><span class="line">标记：                           fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid</span><br></pre></td></tr></table></figure><h2 id="编译前准备"><a href="#编译前准备" class="headerlink" title="编译前准备"></a>编译前准备</h2><h3 id="1、下载源码包"><a href="#1、下载源码包" class="headerlink" title="1、下载源码包"></a>1、下载源码包</h3><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qt.io/archive/qt/5.9/5.9.8/single/qt-everywhere-opensource-src-5.9.8.tar.xz</span><br><span class="line"></span><br><span class="line">xz -d qt-everywhere-opensource-src-5.9.8.tar.xz</span><br><span class="line">tar -xvf qt-everywhere-opensource-src-5.9.8.tar</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> qt-everywhere-opensource-src-5.9.8</span><br><span class="line">vim qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf</span><br><span class="line">根据系统gcc版本替换</span><br><span class="line">   vim下执行</span><br><span class="line">:%s/arm-linux-gnueabihf/aarch64-linux-gnu/g</span><br><span class="line"></span><br><span class="line">注释</span><br><span class="line">vim qtimageformats/src/3rdparty/libwebp/src/dsp/dsp.h 第72行</span><br><span class="line"></span><br><span class="line">//<span class="comment">#define WEBP_USE_NEON  // Android targets that might support NEON</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="2、配置需要编译的包集合"><a href="#2、配置需要编译的包集合" class="headerlink" title="2、配置需要编译的包集合"></a>2、配置需要编译的包集合</h3><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix /usr/local/Qt-5.9 -release -xplatform linux-arm-gnueabi-g++ -opensource -nomake examples -nomake tests -confirm-license -shared -no-iconv -qt-xcb -no-opengl -skip qtlocation</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">如果make install出现以下错误:</span><br><span class="line">出现error: ‘SIOCGSTAMP’ undeclared (first use <span class="keyword">in</span> this <span class="keyword">function</span>); did you mean ‘SIOCGARP’</span><br><span class="line"></span><br><span class="line">在socketcanbackend.cpp文件中添加<span class="comment">#include &lt;linux/sockios.h&gt;</span></span><br><span class="line"></span><br><span class="line">即:</span><br><span class="line">vim qtserialbus/src/plugins/canbus/socketcan/socketcanbackend.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure>编译过程中还可能出现webp报错的情况，此时执行`./configure`配置时增加不编译`webp`选项,即：`-no-webp`</code></pre><h3 id="3、添加Qt环境"><a href="#3、添加Qt环境" class="headerlink" title="3、添加Qt环境"></a>3、添加Qt环境</h3><pre><code>如果系统已经存在qt版本，则如下配置:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qtchooser -install Qt-5.9 /usr/local/Qt-5.9/bin/qmake</span><br><span class="line"></span><br><span class="line">设置系统默认qt版本</span><br><span class="line"><span class="built_in">export</span> QT_SELECT=Qt-5.9</span><br></pre></td></tr></table></figure>如果系统未安装过qt，则配置如下:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> QTDIR=/usr/local/Qt-5.9</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$QTDIR</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> MANPATH=<span class="variable">$QTDIR</span>/man:<span class="variable">$MANPATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$QTDIR</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录在麒麟V10&lt;code&gt;aarch64/Phytium,FT-2000/4&lt;/code&gt;上编译&lt;code&gt;Qt-5.9.8&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://yesir.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>shell获取桌面等路径</title>
    <link href="https://yesir.github.io/2022/12/21/shell%E8%8E%B7%E5%8F%96%E6%A1%8C%E9%9D%A2%E7%AD%89%E8%B7%AF%E5%BE%84/"/>
    <id>https://yesir.github.io/2022/12/21/shell%E8%8E%B7%E5%8F%96%E6%A1%8C%E9%9D%A2%E7%AD%89%E8%B7%AF%E5%BE%84/</id>
    <published>2022-12-21T03:29:51.000Z</published>
    <updated>2022-12-21T03:33:13.488Z</updated>
    
    <content type="html"><![CDATA[<p>在不知道当前用户的情况下，需要将文件拷贝到桌面这一级目录时，可以利用<code>~/.config/user-dirs.dirs</code>配置文件来获取</p><span id="more"></span><blockquote><p>脚本如下:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">desk=`<span class="built_in">cat</span> <span class="variable">$HOME</span>/.config/user-dirs.dirs | grep DESKTOP | <span class="built_in">tail</span>  -1  |<span class="built_in">cut</span> -d <span class="string">&#x27;=&#x27;</span> -f 2  | sed <span class="string">&#x27;s/\&quot;//g&#x27;</span>`</span><br><span class="line">var=`<span class="built_in">eval</span> <span class="built_in">echo</span> <span class="variable">$desk</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在不知道当前用户的情况下，需要将文件拷贝到桌面这一级目录时，可以利用&lt;code&gt;~/.config/user-dirs.dirs&lt;/code&gt;配置文件来获取&lt;/p&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://yesir.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
